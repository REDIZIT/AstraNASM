# 1. Tokenizer / Lexer
Превращение символов в токены
#### Участвуют:
1. Lexer - скрипт, который последовательно читает код на Астре и переводит их в токены
2. Token - абстрактный класс для каждого токена (Token_If, Token_Return и тд)




# 2. AST
Превращение токенов в Node. Построение абстрактного синтаксического дерева.
#### Участвуют:
1. ASTBuilder - абстрактный класс, который имеет инструменты для построения дерева из токенов
2. AstraAST - наследник ASTBuilder, который использует инструменты согласно прописанным правилам и строит дерево.
3. Node - абстрактный класс для каждой ноды (Node_If, Node_Return, Node_Binary и тд)
#### Ограничения и особенности:
В процессе построения дерева ещё недоступны внутриязыковые типы так как разрешением типов занимается Resolver, а сделать это он сможет только когда дерево будет построено.
То есть, <u>можно работать только с строковыми именами типов</u>.






# 3. Resolver
Обходит дерево и разрешает зависимости нод (например, разрешает имена типов в конкретные типы).

Проходы:
#### 1. Регистрация встроенных типов
Регистрация встроенных типов (byte, short, int, long, bool, ptr, string)

#### 2. Регистрация пользовательских типов
Обход дерева в поиске Node_Class и регистрация этого типа.
<u>Важно</u>: регистрируется только тип, без полей, без всего.

#### 3. Регистрация полей
Проходим по каждому зарегистрированному типу. Для каждого типа регистрируем его поля.
Теперь внутри типа есть поля.

#### 4. Регистрация функций
Проходим по каждому типу и регистрируем все функции внутри них.
Теперь внутри типа есть функции.

#### 5. Регистрация констант (строк)
Проходим по всем нодам в поисках Node_Literal, чей тип является строкой (Token_String). Регистрируем каждую строку в отдельном месте, а в Node_Literal, в качестве значения, указываем не всю строку, а лишь указатель на строку.

#### 6. Создание областей видимостей (Scope)
Создаём один большой global scope.

Идём по дереву вниз, если натыкаемся на ноду, для которой нужно создать local scope (Node_Class, Node_Function, Node_TryCatch и прочее), то создаём дочерний scope от предыдущего и идём дальше.

В момент создания local scope, мы регистрируем все переменные для ноды для который и создаётся local scope.
Так же, если мы заходим внутрь типа (класса) или функции, то и это мы регистрируем тоже.

#### 7. Разрешение нод
Проходим по всему дереву. Если ноде нужно разрешить тип или FunctionInfo или ещё что-то, то Resolver это делает.
Пример: для Node_New нужно разрешить тип на основании его строкового имени


#### Участвуют:
1. Resolver
2. ResolvedModule
3. Scope
4. globalScope - не используется, А ДОЛЖЕН!!!




# 4. Generator
Обход дерева и создание кода (байт-код / ассембли)

Для работы требуется готовое дерево, а так же ResolvedModule.

#### 1. Инъекция переменных окружения
Актуально только для NASM сборки с линковкой.
Не актуально (не имеет поддержки) для AVM.

Компилятор имеет возможность подставить в определённые переменные значения в зависимости от окружения.
Например: в переменную с названием binary_src_font_psf_start он может подставить адрес шрифта в процессе линковки.

#### 2. Регистрация констант (строк)
Для каждой строки, которая была зарегистрирована ранее Resolver'ом, генератор создаёт место, куда записывает значение строк.

#### 3. Генерация
Генератор вызывает лишь одну функцию Generate у самой верхней ноды, а эта нода, вызывает Generate у дочерних, и так далее, по всему дереву.

При генерации используются контекст ctx, в который записывается байт или nasm код, а также ResolvedModule (<u>важно: надо удалить</u>)


#### Участвуют:
1. Generator
2. Generator.Context
3. CodeGenerator_ByteCode / CodeGenerator_NASM








# 5. Execute
Плоское чтение кода и его выполнение в runtime.
Это задача AVM.